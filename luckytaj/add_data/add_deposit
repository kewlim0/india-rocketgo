from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options as ChromeOptions
from webdriver_manager.chrome import ChromeDriverManager
import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import os
from selenium.webdriver.support.ui import Select
from datetime import datetime
from os_date_utils import select_os_type, format_date_for_calendar
import re
from selenium.webdriver import ActionChains
from selenium.common.exceptions import TimeoutException
import subprocess
import threading
import queue
from terminal_utils import setup_automation_terminal, cleanup_terminal, print_status



def wait_for_overlay_to_disappear(driver, max_wait=5):
    """Fast overlay detection - only wait if overlay actually exists"""
    overlay_selectors = [
        "div.absolute.inset-0.transition-opacity.duration-300.bg-slate-900\\/60",
        ".app-preloader",
        "div.app-preloader"
    ]
    
    overlay_found = False
    for selector in overlay_selectors:
        try:
            # Quick check if overlay exists
            overlays = driver.find_elements(By.CSS_SELECTOR, selector)
            if overlays and overlays[0].is_displayed():
                enhanced_print(f"[INFO] {selector} overlay detected, waiting...")
                WebDriverWait(driver, max_wait).until(
                    EC.invisibility_of_element_located((By.CSS_SELECTOR, selector))
                )
                overlay_found = True
                enhanced_print(f"[INFO] {selector} overlay disappeared")
        except:
            continue
    
    if overlay_found:
        time.sleep(0.3)  # Brief wait for DOM stability
        return True
    return False


def smart_click(element, verify_callback=None):
    """
    Smart click with minimal retries - only retry if overlay blocks
    """
    try:
        # Try normal click first
        element.click()
        
        # Quick verification if callback provided
        if verify_callback:
            time.sleep(0.3)
            if verify_callback():
                return True
            else:
                # Only retry if overlay is blocking
                if wait_for_overlay_to_disappear(driver, max_wait=3):
                    element.click()
                    time.sleep(0.3)
                    return verify_callback()
                return False
        return True
        
    except Exception as click_error:
        error_msg = str(click_error)
        # Only retry if it's an overlay blocking issue
        if "obscures it" in error_msg or "not clickable" in error_msg:
            enhanced_print("[INFO] Overlay blocking click, trying JS click...")
            if wait_for_overlay_to_disappear(driver, max_wait=3):
                try:
                    driver.execute_script("arguments[0].click();", element)
                    if verify_callback:
                        time.sleep(0.3)
                        return verify_callback()
                    return True
                except Exception as js_click_error:
                    enhanced_print(f"[INFO] JS click also failed: {js_click_error}")
                    enhanced_print("[INFO] Pressing Enter to dismiss modal/overlay...")
                    element.send_keys(Keys.ENTER)
                    time.sleep(0.5)
                    if verify_callback:
                        return verify_callback()
                    return True
        raise click_error


def reliable_click_with_locator(locator, max_attempts=3, delay=1, verify_callback=None):
    """
    Click element using locator to handle stale elements
    """
    for attempt in range(max_attempts):
        try:
            enhanced_print(f"[INFO] Attempting click with locator (attempt {attempt + 1}/{max_attempts})")
            
            # Wait for any overlays to disappear
            wait_for_overlay_to_disappear(driver, max_wait=3)
            
            # Re-find element to avoid stale reference
            element = WebDriverWait(driver, 20).until(
                EC.element_to_be_clickable(locator)
            )
            
            # Scroll element into view
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", element)
            time.sleep(0.3)
            
            # Try normal click first
            try:
                element.click()
                enhanced_print("[INFO] Normal click successful")
            except Exception as click_error:
                enhanced_print(f"[WARN] Normal click failed: {click_error}")
                # Fallback to JavaScript click
                enhanced_print("[INFO] Trying JavaScript click...")
                driver.execute_script("arguments[0].click();", element)
                enhanced_print("[INFO] JavaScript click successful")
            
            time.sleep(0.5)
            
            # If verification callback provided, use it
            if verify_callback and not verify_callback():
                if attempt < max_attempts - 1:
                    enhanced_print(f"[WARN] Click verification failed, retrying in {delay} seconds...")
                    time.sleep(delay)
                    continue
                else:
                    enhanced_print("[ERROR] Click verification failed after all attempts")
                    return False
            
            enhanced_print("[INFO] Click successful")
            return True
            
        except Exception as e:
            enhanced_print(f"[WARN] Click attempt {attempt + 1} failed: {e}")
            if attempt < max_attempts - 1:
                time.sleep(delay)
            else:
                enhanced_print(f"[ERROR] All click attempts failed: {e}")
                raise e
    return False


def reliable_click(element, max_attempts=3, delay=1, verify_callback=None):
    """
    Click element with retry mechanism, overlay handling, and stale element recovery
    """
    for attempt in range(max_attempts):
        try:
            enhanced_print(f"[INFO] Attempting click (attempt {attempt + 1}/{max_attempts})")
            
            # Wait for any overlays to disappear
            wait_for_overlay_to_disappear(driver, max_wait=3)
            
            # Scroll element into view
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", element)
            time.sleep(0.3)
            
            # Try normal click first
            try:
                element.click()
                enhanced_print("[INFO] Normal click successful")
            except Exception as click_error:
                enhanced_print(f"[WARN] Normal click failed: {click_error}")
                # Fallback to JavaScript click
                enhanced_print("[INFO] Trying JavaScript click...")
                driver.execute_script("arguments[0].click();", element)
                enhanced_print("[INFO] JavaScript click successful")
            
            time.sleep(0.5)
            
            # If verification callback provided, use it
            if verify_callback and not verify_callback():
                if attempt < max_attempts - 1:
                    enhanced_print(f"[WARN] Click verification failed, retrying in {delay} seconds...")
                    time.sleep(delay)
                    continue
                else:
                    enhanced_print("[ERROR] Click verification failed after all attempts")
                    return False
            
            enhanced_print("[INFO] Click successful")
            return True
            
        except Exception as e:
            error_msg = str(e)
            enhanced_print(f"[WARN] Click attempt {attempt + 1} failed: {e}")
            
            # Check if it's a stale element error
            if "stale" in error_msg.lower() or "not connected to the DOM" in error_msg:
                enhanced_print("[WARN] Stale element detected - element needs to be re-found")
                
            if attempt < max_attempts - 1:
                time.sleep(delay)
            else:
                enhanced_print(f"[ERROR] All click attempts failed: {e}")
                raise e
    return False


def verify_dropdown_opened(driver):
    """Verify dropdown is opened by checking for dropdown options"""
    try:
        dropdown_options = driver.find_elements(By.CSS_SELECTOR, ".ts-dropdown, .dropdown-menu, [role='listbox']")
        return len(dropdown_options) > 0
    except:
        return False


def verify_modal_opened(driver):
    """Verify modal/popup window is opened"""
    try:
        modal = driver.find_elements(By.CSS_SELECTOR, ".flex.justify-between.px-4.py-3.rounded-t-lg.bg-slate-200.dark\\:bg-navy-800.sm\\:px-5")
        return len(modal) > 0 and modal[0].is_displayed()
    except:
        return False


def verify_calendar_opened(driver):
    """Verify calendar popup is opened"""
    try:
        calendar = driver.find_elements(By.CLASS_NAME, "flatpickr-calendar")
        return len(calendar) > 0 and "open" in calendar[0].get_attribute("class")
    except:
        return False


def check_player_id_toast(driver, timeout=10):
    """
    Waits up to `timeout` seconds to see if the 'player id field is required' toast appears.
    Prints log if found, returns True/False.
    """
    try:
        toast = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located(
                (By.XPATH, "//div[contains(@class, 'toastify') and contains(text(), 'The player id field is required.')]")
            )
        )
        enhanced_print("[LOG] Toast appeared: Player ID field is required.")
        return True
    except TimeoutException:
        return False
    
def check_transaction_complete_toast(driver, timeout=30):
    """
    Waits up to `timeout` seconds to see if the 'Transaction added successfully.' toast appears.
    If toast doesn't appear, presses Enter every 1 second until found or timeout.
    """
    import time
    from selenium.webdriver.common.keys import Keys

    start_time = time.time()

    while time.time() - start_time < timeout:
        try:
            # Check for toast with a short timeout
            toast = WebDriverWait(driver, 1).until(
                EC.presence_of_element_located(
                    (By.XPATH, "//div[contains(@class, 'toastify') and contains(text(), 'Transaction added successfully.')]")
                )
            )
            enhanced_print("[LOG] Toast appeared: Transaction added successfully.")
            return True
        except TimeoutException:
            # Press Enter and wait 1 second before next attempt
            try:
                driver.find_element(By.TAG_NAME, 'body').send_keys(Keys.ENTER)
                enhanced_print("[LOG] Pressed Enter, waiting for toast...")
                time.sleep(1)
            except Exception as e:
                enhanced_print(f"[WARNING] Could not press Enter: {e}")
                time.sleep(1)

    enhanced_print(f"[WARNING] Toast not found after {timeout} seconds of pressing Enter")
    return False





def click_bank_transactions_link(driver, timeout=5):
    """
    Waits up to `timeout` seconds for the bank transactions link to appear,
    then clicks it. Returns True if clicked, False otherwise.
    """
    try:
        link = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//a[@href='https://www.rocketgo.asia/op/bank-transactions']")
            )
        )
        link.click()
        enhanced_print("[LOG] Clicked Bank Transactions link.")
        return True
    except TimeoutException:
        enhanced_print("[LOG] Bank Transactions link not found within timeout.")
        return False



# Windows Firefox profile path (comment out if you want a fresh profile)
# profile_path = "C:\\Users\\BDC Computer ll\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\your-profile-name"
# firefox_profile = webdriver.FirefoxProfile(profile_path)

options = Options()
# options.set_preference("profile", profile_path)  # Commented out for fresh profile
# Optional: Use a separate Firefox profile
# Replace 'selenium-profile' with the name of a Firefox profile youâ€™ve created
# or comment out if you want a fresh profile every time
# options.profile = "/Users/admin/Library/Application Support/Firefox/Profiles/xxxxxxxx.selenium-profile"

# Headless mode if needed
# options.add_argument('--headless')

# Driver will be initialized after function definitions



# ======== Status Terminal Setup ========
status_queue = queue.Queue()
status_process = None

def create_status_terminal():
    """Create a separate Windows terminal for status display"""
    global status_process
    try:
        # Create a batch file to keep the terminal open with custom size
        batch_content = '''@echo off
mode con: cols=80 lines=25
title Selenium Status Monitor
echo ========================================
echo     SELENIUM DEPOSIT AUTOMATION STATUS
echo ========================================
echo.
echo Waiting for status updates...
echo.
python -c "import sys, time; exec(open('status_monitor.py').read())" 2>nul
if not exist status_monitor.py (
    python -c "import time; [print(f'[{time.strftime(\"%%H:%%M:%%S\")}] Status monitor running... Press Ctrl+C to close') or time.sleep(2) for _ in iter(int, 1)]"
)
pause
'''

        with open('status_terminal.bat', 'w') as f:
            f.write(batch_content)

        # Start the terminal with custom size
        status_process = subprocess.Popen(
            ['cmd', '/c', 'start', 'status_terminal.bat'],
            shell=True,
            creationflags=subprocess.CREATE_NEW_CONSOLE
        )
        enhanced_print("[INFO] Status terminal window opened")
        return True
    except Exception as e:
        enhanced_print(f"[WARNING] Could not create status terminal: {e}")
        return False

def log_to_status_terminal(message):
    """Log message to the status terminal"""
    try:
        # Write to a status file that the terminal monitors (without timestamp)
        with open('status_log.txt', 'a', encoding='utf-8') as f:
            f.write(f"{message}\n")
    except Exception as e:
        pass  # Fail silently if status logging fails

def enhanced_print(message, status_only=False):
    """Print to both main console and status terminal"""
    # Remove emojis from message
    import re
    clean_message = re.sub(r'[\U0001F600-\U0001F64F\U0001F300-\U0001F5FF\U0001F680-\U0001F6FF\U0001F700-\U0001F77F\U0001F780-\U0001F7FF\U0001F800-\U0001F8FF\U0001F900-\U0001F9FF\U0001FA00-\U0001FA6F\U0001FA70-\U0001FAFF\U00002702-\U000027B0\U000024C2-\U0001F251]', '', message)

    if not status_only:
        print(clean_message)
    log_to_status_terminal(clean_message)

# Initialize status logging
enhanced_print("Starting Selenium Deposit Automation")

# Create status terminal
if create_status_terminal():
    enhanced_print("Status monitoring terminal opened")
else:
    enhanced_print("Status terminal creation failed - continuing without separate window")

# Setup terminal with custom settings
setup_automation_terminal("Add Deposit")

# Select operating system for date formatting
os_type = select_os_type()

# ======== Website Configuration ========
website_configs = {
    "1": {
        "name": "luckytaj.com",
        "merchant_code": "luckytaj",
        "username": "Admin_Json",
        "password": "json8888"
    },
    "2": {
        "name": "1taj.com",
        "merchant_code": "1taj",
        "username": "alex_1taj",
        "password": "asdf8888"
    }
}


def select_website():
    """Display menu and get user selection"""
    print("\n" + "="*50)
    print("           SELECT WEBSITE")
    print("="*50)

    for key, config in website_configs.items():
        print(f"{key}. {config['name']}")

    print("="*50)

    while True:
        try:
            choice = input("Enter your choice (1-2): ").strip()
            if choice in website_configs:
                selected_config = website_configs[choice]
                enhanced_print(f"\nSelected: {selected_config['name']}")
                enhanced_print(f"Merchant: {selected_config['merchant_code']}")
                enhanced_print(f"Username: {selected_config['username']}")
                enhanced_print("-"*50)
                return selected_config
            else:
                print("Invalid choice. Please enter 1 or 2.")
        except KeyboardInterrupt:
            print("\n\nOperation cancelled by user")
            exit(0)

def remove_bom(line):
    """Remove BOM (Byte Order Mark) from line if present"""
    BOM = '\ufeff'
    if line.startswith(BOM):
        return line.lstrip(BOM)
    return line

def get_start_by_transaction_id():
    """Prompt user for last processed deposit and withdrawal IDs."""
    print("\n" + "="*60)
    print("     TRANSACTION ID FILTER")
    print("="*60)
    print("Enter the last processed transaction ID.")
    print("Only transactions with a HIGHER numeric ID will be processed.")
    print("Press Enter to skip (process all).\n")

    deposit_id = input("Last deposit ID (e.g. LTJPD164443) or Enter to skip: ").strip()
    withdrawal_id = input("Last withdrawal ID (e.g. LTJPW12324) or Enter to skip: ").strip()

    deposit_cutoff = None
    withdrawal_cutoff = None

    if deposit_id:
        match = re.search(r'(\d+)$', deposit_id)
        if match:
            deposit_cutoff = int(match.group(1))
            print(f"  â†’ Will process deposits with ID > {deposit_cutoff}")

    if withdrawal_id:
        match = re.search(r'(\d+)$', withdrawal_id)
        if match:
            withdrawal_cutoff = int(match.group(1))
            print(f"  â†’ Will process withdrawals with ID > {withdrawal_cutoff}")

    if not deposit_cutoff and not withdrawal_cutoff:
        print("  â†’ No filter set. Processing ALL transactions.")

    return deposit_cutoff, withdrawal_cutoff

# Select website configuration
config = select_website()
enhanced_print(f"Selected website: {config['name']}")

# Get transaction ID filter configuration
deposit_cutoff, withdrawal_cutoff = get_start_by_transaction_id()

# ======== Setup the driver with error handling ========
try:
    enhanced_print("ðŸ”§ Setting up Firefox driver...")
    service = Service(GeckoDriverManager().install())
    driver = webdriver.Firefox(service=service, options=options)
    driver.maximize_window()
    enhanced_print("âœ… Firefox driver started successfully")
except Exception as e:
    enhanced_print(f"âŒ Firefox driver failed to start: {e}")
    enhanced_print("\nðŸ”§ Trying alternative Firefox setup...")
    try:
        # Try without GeckoDriverManager
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        service = Service()  # Use system geckodriver
        driver = webdriver.Firefox(service=service, options=options)
        driver.maximize_window()
        enhanced_print("âœ… Firefox driver started with alternative setup")
    except Exception as e2:
        enhanced_print(f"âŒ Alternative Firefox setup also failed: {e2}")
        enhanced_print("\nðŸ”§ Trying Chrome as fallback...")
        try:
            chrome_options = ChromeOptions()
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_service = ChromeService(ChromeDriverManager().install())
            driver = webdriver.Chrome(service=chrome_service, options=chrome_options)
            driver.maximize_window()
            enhanced_print("âœ… Chrome driver started successfully as fallback")
        except Exception as e3:
            enhanced_print(f"âŒ Chrome fallback also failed: {e3}")
            enhanced_print("\nðŸ’¡ Troubleshooting suggestions:")
            enhanced_print("1. Make sure Firefox or Chrome is installed and updated")
            enhanced_print("2. Try restarting your computer")
            enhanced_print("3. Check if any antivirus is blocking webdrivers")
            enhanced_print("4. Run as administrator")
            enhanced_print("5. Try running: pip install --upgrade selenium webdriver-manager")
            import sys
            sys.exit(1)

# Login with selected configuration
enhanced_print(f"\nConnecting to RocketGo for {config['name']}...")
driver.get("https://www.rocketgo.asia/login")
enhanced_print("Loading login page...")

wait = WebDriverWait(driver, 40)
merchant_input = wait.until(EC.presence_of_element_located((By.NAME, "merchant_code")))
merchant_input.send_keys(config['merchant_code'])

wait = WebDriverWait(driver, 40)
username_input = wait.until(EC.presence_of_element_located((By.NAME, "username")))
username_input.send_keys(config['username'])

wait = WebDriverWait(driver, 40)
password_input = wait.until(EC.presence_of_element_located((By.NAME, "password")))
password_input.send_keys(config['password'] + Keys.ENTER)

enhanced_print(f"Login attempted for {config['name']}")

time.sleep(3)

enhanced_print("Navigating to Bank Transactions...")
click_bank_transactions_link(driver)
wait_for_overlay_to_disappear(driver, max_wait=5)
enhanced_print("Bank Transactions page loaded")



def gateway_setup_movement(gateway_name):
    enhanced_print(f"\033[93m[Gateway Setup] Executing setup for {gateway_name}\033[0m")

    gateway_map = {
        "XYPAY": "XYPAY",
        "XCPAY": "XCPAY",
        "SKPAY": "SKPAY",
        "YTPAY": "YTPAY",
        "OSPAY": "OSPAY",
        "SIMPLYPAY": "SIMPLYPAY",
        "VADERPAY": "VADERPAY",
        "PASSPAY": "PASSPAY",
        "MULTIPAY": "MULTIPAY",
        "U9PAY": "U9PAY",
        "BOMBAYPAY": "BOMBAYPAY",
        "EPAY": "EPAY",
        "MOHAMMED AMEER ABBAS": "Karnataka Bank 2",
        "Test": "Test",
        "Test2" : "Test2",
        "BOPAY": "BOPAY",
        "CPUPAY": "CPUPAY",
        "MAINPAY": "MAINPAY",
        "TOPPAY": "TOPPAY",
        "crypto": "TMX CRYPTO"
    }

    if gateway_name in gateway_map:
        enter_gateway_name(gateway_map[gateway_name])



def enter_gateway_name(gateway_text):
    # Step 1: Wait for preloader to disappear
    WebDriverWait(driver, 30).until(
        EC.invisibility_of_element_located((By.CLASS_NAME, "app-preloader"))
    )

    # Step 2: Click container to open dropdown using locator-based approach
    time.sleep(0.5)
    driver.execute_script("window.scrollTo(0, 0);")
    time.sleep(1)  # Optional: wait for any sticky headers to settle
    
    # Click dropdown container to open it
    container = WebDriverWait(driver, 20).until(
        EC.element_to_be_clickable((By.CSS_SELECTOR, "div.ts-control"))
    )
    smart_click(container, verify_callback=lambda: verify_dropdown_opened(driver))
    time.sleep(0.5)

    # Step 3: Find actual input (not always interactable)
    gateway_input = WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.ID, "selectBank-ts-control"))
    )

    # Optional: Scroll it into view
    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", gateway_input)
    time.sleep(0.3)

    # enhanced_print("Displayed:", gateway_input.is_displayed())
    # enhanced_print("Enabled:", gateway_input.is_enabled())
    # enhanced_print("Size:", gateway_input.size)
    # enhanced_print("Location:", gateway_input.location)

    try:
        # Try normal input method first
        gateway_input.send_keys(gateway_text)
    except Exception as e:
        enhanced_print(f"[WARN] Normal input failed, using JS. Reason: {e}")
        # Fallback to JS-based input
        driver.execute_script("""
            arguments[0].value = arguments[1];
            arguments[0].dispatchEvent(new Event('input', { bubbles: true }));
        """, gateway_input, gateway_text)

    time.sleep(2)  # Wait for dropdown options

    # Step 4: Check if dropdown has valid options before selection
    try:
        # Check for dropdown options
        dropdown_options = driver.find_elements(By.CSS_SELECTOR, ".ts-dropdown .option, .ts-dropdown-content .option, [data-selectable='true'], .dropdown-item")
        
        if len(dropdown_options) == 0:
            enhanced_print("[WARN] No dropdown options found, checking for alternative selectors...")
            # Try alternative selectors for dropdown options
            alternative_selectors = [
                ".ts-dropdown [data-value]",
                ".dropdown-menu li",
                ".select-dropdown li",
                "[role='option']",
                ".ts-dropdown > div"
            ]
            
            for selector in alternative_selectors:
                dropdown_options = driver.find_elements(By.CSS_SELECTOR, selector)
                if len(dropdown_options) > 0:
                    enhanced_print(f"[INFO] Found {len(dropdown_options)} options with selector: {selector}")
                    break
        
        if len(dropdown_options) > 0:
            enhanced_print(f"[INFO] Found {len(dropdown_options)} dropdown options")
            # Press Enter to select the first matching option
            gateway_input.send_keys(Keys.ENTER)
            enhanced_print(f"[INFO] Gateway '{gateway_text}' entered and selected.")
        else:
            enhanced_print("[WARN] No dropdown options available - the dropdown might be undefined/empty")
            enhanced_print("[INFO] Trying to proceed without selection...")
            # Try pressing Enter anyway in case the input is accepted
            gateway_input.send_keys(Keys.ENTER)
            enhanced_print(f"[INFO] Attempted to enter '{gateway_text}' without dropdown options.")
            
    except Exception as e:
        enhanced_print(f"[WARN] Error checking dropdown options: {e}")
        # Fallback - try pressing Enter anyway
        gateway_input.send_keys(Keys.ENTER)
        enhanced_print(f"[INFO] Fallback: Attempted to enter '{gateway_text}'.")
    
    time.sleep(0.5)





    # --- Check Table load with multiple selectors ---
    enhanced_print("[INFO] Waiting for table to load...")
    table_selectors = [
        (By.CLASS_NAME, "gridjs-wrapper"),
        (By.CSS_SELECTOR, ".gridjs-wrapper"),
        (By.CSS_SELECTOR, "table"),
        (By.CSS_SELECTOR, ".table"),
        (By.CSS_SELECTOR, "[role='table']"),
        (By.CSS_SELECTOR, ".data-table"),
        (By.CSS_SELECTOR, ".grid-table")
    ]
    
    table_loaded = False
    wait = WebDriverWait(driver, 45)  # Increased timeout
    
    for selector in table_selectors:
        try:
            wait.until(EC.presence_of_element_located(selector))
            enhanced_print(f"[INFO] Table loaded with selector: {selector}")
            table_loaded = True
            break
        except Exception as e:
            enhanced_print(f"[DEBUG] Table selector {selector} failed: {e}")
            continue
    
    if not table_loaded:
        enhanced_print("[WARN] Table loading timeout - proceeding anyway")
    
    time.sleep(2)  # Additional wait for table content to populate



# ======== Add Details HERE =======


def add_transaction_details(record):
    """Fill Order ID, Phone Number, Amount, Date, and Time into form."""
    enhanced_print(f"Processing Record: Order ID \033[92m{record.get('Order ID', 'Unknown')}\033[0m")
    enhanced_print(f"   Amount: {record.get('Amount', 'Unknown')}")
    enhanced_print(f"   Phone: {record.get('Phone Number', 'Unknown')}")
    enhanced_print(f"   Type: {record.get('transaction_type', 'DEPOSIT')}")

    # Wait briefly for page load
    time.sleep(2.5)

    # Find Add button
    wait = WebDriverWait(driver, 20)
    add_button = wait.until(EC.element_to_be_clickable((
        By.XPATH, "//button[contains(text(), 'Add New Bank Transaction')]"
    )))

    # Click Add Transaction button with overlay handling
    try:
        wait_for_overlay_to_disappear(driver, max_wait=2)
        add_button.click()
        enhanced_print("[INFO] Add Transaction button clicked")
    except Exception as e:
        enhanced_print(f"[WARNING] Click failed: {e}")
        try:
            driver.execute_script("arguments[0].click();", add_button)
            enhanced_print("[INFO] Used JavaScript click as fallback")
        except Exception as js_e:
            enhanced_print(f"[ERROR] JavaScript click also failed: {js_e}")

    # Wait for modal to appear
    WebDriverWait(driver, 20, poll_frequency=0.2).until(
        EC.presence_of_element_located((
            By.CSS_SELECTOR, ".flex.justify-between.px-4.py-3.rounded-t-lg.bg-slate-200.dark\\:bg-navy-800.sm\\:px-5"
        ))
    )
    enhanced_print("[INFO] Target Window element appeared â€” proceeding...")

    # Click 'out' radio button for withdrawal transactions
    transaction_type = record.get("transaction_type", "DEPOSIT")
    if transaction_type == "WITHDRAWAL":
        enhanced_print("[INFO] WITHDRAWAL detected - clicking 'out' radio button")
        wait = WebDriverWait(driver, 15)
        out_radio = wait.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, 'input[type="radio"][value="out"]'))
        )
        smart_click(out_radio)
        enhanced_print("[INFO] Successfully clicked 'out' radio button")

    # ===== Order ID =====
    order_id_input = WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, "//input[@placeholder='Bank Reference']"))
    )
    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", order_id_input)
    time.sleep(0.3)
    order_id_input.clear()
    order_id_input.send_keys(record["Order ID"])
    enhanced_print(f"[INFO] Order ID entered: {record['Order ID']}")

    # ===== Phone Number =====
    phone_number_input = WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, "//input[@placeholder='Player ID']"))
    )
    try:
        driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", phone_number_input)
        time.sleep(0.3)
        phone_number_input.clear()
    except Exception as clear_error:
        enhanced_print(f"[DEBUG] Clear failed: {clear_error}, trying JavaScript approach...")
        driver.execute_script("arguments[0].value = '';", phone_number_input)
    try:
        phone_number_input.send_keys(record["Phone Number"])
        enhanced_print(f"[INFO] Phone Number entered: {record['Phone Number']}")
    except Exception as send_error:
        enhanced_print(f"[DEBUG] Send keys failed: {send_error}, trying JavaScript...")
        driver.execute_script("arguments[0].value = arguments[1];", phone_number_input, record["Phone Number"])
        enhanced_print(f"[INFO] Phone Number entered with JavaScript: {record['Phone Number']}")

    # ===== Amount =====
    amount_input = WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, "//input[@placeholder='amount']"))
    )
    amount_input.clear()
    amount_input.send_keys(str(record["Amount"]).replace(",", ""))
    enhanced_print(f"[INFO] Amount entered: {record['Amount']}")

    # ===== Datepicker =====
    calendar_input = WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, "//input[@placeholder='Choose datetime...']"))
    )
    smart_click(calendar_input, verify_callback=lambda: verify_calendar_opened(driver))
    enhanced_print("[INFO] Calendar input clicked...")

    calendar_popup = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.CLASS_NAME, "flatpickr-calendar"))
    )

    if "open" in calendar_popup.get_attribute("class"):
        enhanced_print("[INFO] Calendar popup is OPEN")
        target_date = format_date_for_calendar(record["Datetime"], os_type)
        all_days = driver.find_elements(By.CSS_SELECTOR, ".flatpickr-day")
        for day in all_days:
            if day.get_attribute("aria-label") == target_date:
                driver.execute_script("arguments[0].scrollIntoView(true);", day)
                smart_click(day)
                enhanced_print(f"[INFO] Clicked date: {target_date}")
                break
        else:
            enhanced_print(f"[ERROR] Date '{target_date}' not found in picker.")
    else:
        enhanced_print("[WARN] Calendar popup did NOT open")

    # ===== Hour =====
    wait = WebDriverWait(driver, 40)
    hour_input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "input.flatpickr-hour")))
    hour_input.clear()
    hour_input.send_keys(record["Hour"])
    time.sleep(0.5)

    # ===== Minutes =====
    wait = WebDriverWait(driver, 40)
    minute_input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "input.flatpickr-minute")))
    minute_input.clear()
    minute_input.send_keys(record["Minute"])
    time.sleep(0.5)

    # ===== AM/PM =====
    ampm_target = "AM" if int(record.get("Hour", 0)) < 12 else "PM"
    ampm_toggle = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.CLASS_NAME, "flatpickr-am-pm"))
    )
    current_ampm = ampm_toggle.text.strip().upper()
    if current_ampm != ampm_target:
        smart_click(ampm_toggle)
        enhanced_print(f"[INFO] AM/PM toggled to {ampm_target}")
    else:
        enhanced_print(f"[INFO] AM/PM already set to {ampm_target}")

    time.sleep(1)

    # Click Player ID field to trigger validation
    try:
        player_id_input = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.XPATH, "//input[@placeholder='Player ID']"))
        )
        driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", player_id_input)
        time.sleep(0.3)
        player_id_input.click()
        enhanced_print("[INFO] Player ID field clicked")
    except Exception as player_click_error:
        enhanced_print(f"[DEBUG] Player ID click failed: {player_click_error}, continuing...")

    time.sleep(1)

    # Confirm calendar selection
    try:
        calendar_input = driver.find_element(By.XPATH, "//input[@placeholder='Choose datetime...']")
        calendar_input.send_keys(Keys.ENTER)
        enhanced_print("[INFO] Calendar selection confirmed via Enter on calendar input")
    except Exception as e:
        enhanced_print(f"[WARN] Could not confirm calendar via input: {e}")
        try:
            driver.find_element(By.TAG_NAME, "body").send_keys(Keys.ENTER)
            enhanced_print("[INFO] Calendar selection confirmed via Enter on body")
        except Exception as e2:
            enhanced_print(f"[WARN] Could not confirm calendar: {e2}")

    time.sleep(0.5)

    # Check for transaction successful toast first
    if check_transaction_complete_toast(driver):
        enhanced_print("[INFO] Transaction added - form submitted")
    else:
        enhanced_print("[INFO] No transaction success toast detected - checking for Player ID errors")

        if check_player_id_toast(driver):
            enhanced_print("\033[91m[WARN]\033[0m Player ID field validation failed - form not submitted")

            # Try pressing Enter up to 5 times with 3s interval
            for attempt in range(5):
                try:
                    body = driver.find_element(By.TAG_NAME, "body")
                    body.send_keys(Keys.ENTER)
                    enhanced_print(f"[INFO] Sent ENTER key to dismiss toast (attempt {attempt+1}/5)")
                    time.sleep(3)
                except Exception as e:
                    enhanced_print(f"[ERROR] Could not send ENTER key: {e}")

            time.sleep(2)
            enhanced_print("[INFO] Checking if Player ID toast still appears after 5 ENTER attempts...")

            if check_player_id_toast(driver, timeout=3):
                enhanced_print("\033[91m[WARN]\033[0m Player ID toast still appears - replacing player ID with custom text")
                try:
                    player_id_input = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.XPATH, "//input[@placeholder='Player ID']"))
                    )
                    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", player_id_input)
                    time.sleep(0.5)
                    player_id_input.clear()
                    time.sleep(0.3)
                    custom_player_id = "not_found"
                    player_id_input.send_keys(custom_player_id)
                    enhanced_print(f"[INFO] Player ID replaced with custom text: {custom_player_id}")
                    time.sleep(1)
                    body = driver.find_element(By.TAG_NAME, "body")
                    body.send_keys(Keys.ENTER)
                    enhanced_print("[INFO] Form re-submitted after replacing Player ID")
                    time.sleep(2)
                except Exception as replace_error:
                    enhanced_print(f"[ERROR] Could not replace Player ID: {replace_error}")
            else:
                enhanced_print("[INFO] Player ID toast dismissed successfully after ENTER attempts")
        else:
            enhanced_print("[INFO] No player ID toast detected - form submission successful")

    time.sleep(0.5)










def parse_and_execute(filename, deposit_cutoff=None, withdrawal_cutoff=None):
    with open(filename, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    current_gateway = None
    current_records = []
    performed_gateways = set()
    current_transaction_type = "DEPOSIT"  # Default to DEPOSIT

    supported_gateways = {
        "XYPAY", "SKPAY", "YTPAY", "OSPAY", "SIMPLYPAY", "VADERPAY",
        "PASSPAY", "MULTIPAY", "U9PAY", "BOMBAYPAY", "EPAY",
        "MOHAMMED AMEER ABBAS", "Test", "Test2", "XCPAY", "BOPAY", "CPUPAY",
        "MAINPAY", "TOPPAY", "crypto"
    }

    # Track last processed Order IDs
    last_deposit_id = None
    last_withdrawal_id = None

    # Temporary variables for one record
    order_id = phone = amount = time_str = None
    dt = hour_str = minute_str = None

    for raw_line in lines:
        line = remove_bom(raw_line.strip())

        if not line:
            continue

        # Detect WITHDRAWALS section banner
        if line == "WITHDRAWALS":
            current_transaction_type = "WITHDRAWAL"
            enhanced_print(f"[INFO] Detected WITHDRAWALS section - switching to withdrawal mode")
            continue

        # Detect DEPOSITS section banner
        if line == "DEPOSITS":
            current_transaction_type = "DEPOSIT"
            enhanced_print(f"[INFO] Detected DEPOSITS section - switching to deposit mode")
            continue

        # Stop condition
        if "GRAND TOTAL for All Gateways" in line:
            enhanced_print("[INFO] Reached GRAND TOTAL line. Stopping processing.")
            break

        # Detect gateway header line
        if line.startswith("====") and "Total Amount" in line:
            if current_records:
                enhanced_print(f"[DEBUG] Flushing {len(current_records)} records under gateway '{current_gateway}'")
                for record in current_records:
                    add_transaction_details(record)
            current_records = []

            match = re.match(r"==== (.*?) \(", line)
            if match:
                detected_gateway = match.group(1)
                if detected_gateway in supported_gateways:
                    current_gateway = detected_gateway
                    if current_gateway not in performed_gateways:
                        gateway_setup_movement(current_gateway)
                        performed_gateways.add(current_gateway)
                else:
                    enhanced_print(f"[WARNING] Unsupported gateway '{detected_gateway}', skipping records.")
                    current_gateway = None
            continue

        # Skip if gateway not set
        if not current_gateway:
            continue

        # Parse record fields
        if line.startswith("Order ID:"):
            order_id = line.split(":", 1)[1].strip()
        elif line.startswith("Phone Number:"):
            phone = line.split(":", 1)[1].strip()
        elif line.startswith("Amount:"):
            amount = line.split(":", 1)[1].strip()
        elif line.startswith("Time:"):
            time_str = line.split(":", 1)[1].strip()
            try:
                dt = datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S")
                hour_str = f"{dt.hour:02d}"
                minute_str = f"{dt.minute:02d}"

                if all([order_id, phone, amount, time_str]):
                    # ID-based filtering
                    should_process = True
                    id_match = re.search(r'(\d+)$', order_id)
                    id_num = int(id_match.group(1)) if id_match else 0

                    if current_transaction_type == "DEPOSIT" and deposit_cutoff is not None:
                        if id_num <= deposit_cutoff:
                            enhanced_print(f"[SKIP] Deposit {order_id} (ID {id_num} <= cutoff {deposit_cutoff})")
                            should_process = False
                    elif current_transaction_type == "WITHDRAWAL" and withdrawal_cutoff is not None:
                        if id_num <= withdrawal_cutoff:
                            enhanced_print(f"[SKIP] Withdrawal {order_id} (ID {id_num} <= cutoff {withdrawal_cutoff})")
                            should_process = False

                    if should_process:
                        enhanced_print(f"[PROCESS] {current_transaction_type} {order_id} (ID {id_num})")
                        current_records.append({
                            "Order ID": order_id,
                            "Phone Number": phone,
                            "Amount": amount,
                            "Time": time_str,
                            "Hour": hour_str,
                            "Minute": minute_str,
                            "Datetime": dt,
                            "transaction_type": current_transaction_type
                        })
                        if current_transaction_type == "DEPOSIT":
                            last_deposit_id = order_id
                        elif current_transaction_type == "WITHDRAWAL":
                            last_withdrawal_id = order_id

                    # Reset vars for next record
                    order_id = phone = amount = time_str = None
                    dt = hour_str = minute_str = None
            except ValueError:
                enhanced_print(f"[ERROR] Invalid datetime: {time_str}")
                continue

    # Final flush at EOF
    if current_records:
        enhanced_print(f"[DEBUG] Final flush: {len(current_records)} records under gateway '{current_gateway}'")
        for record in current_records:
            add_transaction_details(record)

    return last_deposit_id, last_withdrawal_id


# ===== Function call HERE =====
# Get relative path for transaction file
script_dir = os.path.dirname(os.path.abspath(__file__))
# Go up two levels: add_data -> luckytaj -> rocketgo auto
working_dir = os.path.dirname(os.path.dirname(script_dir))
transaction_file_path = os.path.join(working_dir, "result", "selenium-transaction_history.txt")

enhanced_print("Starting transaction processing from file...")
last_deposit_id, last_withdrawal_id = parse_and_execute(transaction_file_path, deposit_cutoff, withdrawal_cutoff)
enhanced_print("All transactions processed successfully!")
enhanced_print("Automation completed. Closing browser...")
time.sleep(2)
driver.quit()

# Print and save last processed transaction IDs
last_ids_path = os.path.join(working_dir, "result", "last_transaction_ids.txt")
summary = (
    "="*60 + "\n"
    "       LAST PROCESSED TRANSACTION IDs\n"
    + "="*60 + "\n"
    + f"  Last Deposit ID:    {last_deposit_id if last_deposit_id else '(none processed)'}\n"
    + f"  Last Withdrawal ID: {last_withdrawal_id if last_withdrawal_id else '(none processed)'}\n"
    + "="*60 + "\n"
    + "  Use these IDs as cutoff next time you run the script.\n"
    + "="*60
)
print("\n" + summary + "\n")
with open(last_ids_path, "w", encoding="utf-8") as f:
    f.write(summary + "\n")

# Cleanup
try:
    if os.path.exists('status_terminal.bat'):
        os.remove('status_terminal.bat')
    enhanced_print("Cleanup completed")
except:
    pass

cleanup_terminal()

